#!/usr/bin/env node

/**
 * Script d'automatisation SyllaboKids
 * G√©n√®re les fichiers data JS √† partir du fichier weeks.yaml
 * 
 * Usage: npm run generate:content
 */

import fs from 'fs'
import path from 'path'
import { fileURLToPath } from 'url'
import YAML from 'yaml'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)
const projectRoot = path.resolve(__dirname, '..')

// ==================== CONFIGURATION ====================
const YAML_FILE = path.join(projectRoot, 'content', 'weeks.yaml')
const DATA_DIR = path.join(projectRoot, 'src', 'data')
const OUTPUT_WORDS = path.join(DATA_DIR, 'wordsDatabase.ts')
const OUTPUT_WEEKS = path.join(DATA_DIR, 'weeksProgram.ts')
const OUTPUT_TYPES = path.join(DATA_DIR, 'types.ts')

// ==================== COULEURS POUR CONSOLE ====================
const colors = {
  reset: '\x1b[0m',
  green: '\x1b[32m',
  red: '\x1b[31m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m',
}

function log(color, message) {
  console.log(`${color}${message}${colors.reset}`)
}

// ==================== VALIDATION ====================
function validateYAML(data) {
  const errors = []

  if (!data.weeks || !Array.isArray(data.weeks)) {
    errors.push('‚ùå Structure invalide: "weeks" doit √™tre un tableau')
    return errors
  }

  data.weeks.forEach((week, weekIdx) => {
    if (!week.id || !week.title) {
      errors.push(`‚ùå Semaine ${weekIdx}: "id" et "title" obligatoires`)
    }

    if (!week.sessions || !Array.isArray(week.sessions)) {
      errors.push(`‚ùå Semaine ${week.id}: "sessions" doit √™tre un tableau`)
      return
    }

    week.sessions.forEach((session, sessionIdx) => {
      if (!session.id || !session.title || !session.type) {
        errors.push(
          `‚ùå Semaine ${week.id}, Session ${sessionIdx}: "id", "title", "type" obligatoires`
        )
      }

      if (!session.words || !Array.isArray(session.words)) {
        errors.push(
          `‚ùå Semaine ${week.id}, Session ${session.id}: "words" doit √™tre un tableau`
        )
        return
      }

      session.words.forEach((word, wordIdx) => {
        if (!word.word || !word.syllables || !word.category || !word.emoji) {
          errors.push(
            `‚ùå Semaine ${week.id}, Session ${session.id}, Word ${wordIdx}: tous les champs obligatoires`
          )
        }

        if (!Array.isArray(word.syllables) || word.syllables.length === 0) {
          errors.push(
            `‚ùå "${word.word}": syllables doit √™tre un tableau non-vide`
          )
        }
      })
    })
  })

  return errors
}

// ==================== G√âN√âRATION FICHIERS ====================
function generateWordsDatabase(data) {
  const wordsMap = {}

  data.weeks.forEach((week) => {
    week.sessions.forEach((session) => {
      session.words.forEach((word) => {
        wordsMap[word.word] = {
          syllables: word.syllables,
          count: word.syllables.length,
          category: word.category,
          week: week.id,
          emoji: word.emoji,
        }
      })
    })
  })

  return wordsMap
}

function generateWeeksProgram(data) {
  return data.weeks.map((week) => ({
    id: week.id,
    title: week.title,
    badge: week.badge || { name: 'Badge', icon: '‚≠ê' },
    sessions: week.sessions.map((session) => ({
      id: session.id,
      title: session.title,
      words: session.words.map((w) => w.word),
      type: session.type,
    })),
  }))
}

// ==================== √âCRITURE FICHIERS TYPESCRIPT ====================
function writeWordsFile(wordsMap) {
  const content = `// Auto-generated by generateContent.js - DO NOT EDIT
// Source: content/weeks.yaml

export interface WordData {
  syllables: string[]
  count: number
  category: string
  week: number
  emoji: string
}

export type WordsDatabase = Record<string, WordData>

export const WORDS_DATABASE: WordsDatabase = ${JSON.stringify(wordsMap, null, 2)}
`

  fs.writeFileSync(OUTPUT_WORDS, content, 'utf-8')
  log(colors.green, `‚úì Fichier g√©n√©r√©: ${path.relative(projectRoot, OUTPUT_WORDS)}`)
}

function writeWeeksFile(weeksProgram) {
  const content = `// Auto-generated by generateContent.js - DO NOT EDIT
// Source: content/weeks.yaml

export interface Session {
  id: number
  title: string
  words: string[]
  type: 'syllable_count' | 'first_syllable' | 'build_word' | 'fusion' | 'mixed'
}

export interface Week {
  id: number
  title: string
  badge: {
    name: string
    icon: string
  }
  sessions: Session[]
}

export type WeeksProgram = Week[]

export const WEEKS_PROGRAM: WeeksProgram = ${JSON.stringify(weeksProgram, null, 2)}
`

  fs.writeFileSync(OUTPUT_WEEKS, content, 'utf-8')
  log(colors.green, `‚úì Fichier g√©n√©r√©: ${path.relative(projectRoot, OUTPUT_WEEKS)}`)
}

function writeTypesFile() {
  const content = `// Types pour SyllaboKids
// Auto-generated structure

export type ExerciseType = 'syllable_count' | 'first_syllable' | 'build_word' | 'fusion' | 'mixed'

export interface Profile {
  id: string
  name: string
  avatar: string
  level: number
  totalScore: number
  progress: {
    completedWeeks: number[]
    currentWeek: number
  }
}
`

  fs.writeFileSync(OUTPUT_TYPES, content, 'utf-8')
  log(colors.green, `‚úì Fichier g√©n√©r√©: ${path.relative(projectRoot, OUTPUT_TYPES)}`)
}

// ==================== STATISTIQUES ====================
function printStats(data) {
  const wordCount = data.weeks.reduce(
    (sum, week) =>
      sum + week.sessions.reduce((s, sess) => s + sess.words.length, 0),
    0
  )

  const sessionCount = data.weeks.reduce(
    (sum, week) => sum + week.sessions.length,
    0
  )

  const categories = new Set()
  data.weeks.forEach((week) => {
    week.sessions.forEach((session) => {
      session.words.forEach((word) => {
        categories.add(word.category)
      })
    })
  })

  log(colors.cyan, '\nüìä STATISTIQUES DE CONTENU')
  log(colors.cyan, '‚îÅ'.repeat(50))
  console.log(`  üìö Semaines: ${data.weeks.length}`)
  console.log(`  üìù Sessions: ${sessionCount}`)
  console.log(`  üéØ Mots uniques: ${wordCount}`)
  console.log(`  üè∑Ô∏è  Cat√©gories: ${categories.size}`)
  console.log(`  ‚úÖ Toutes les validations pass√©es!`)
  log(colors.cyan, '‚îÅ'.repeat(50))
}

// ==================== MAIN ====================
async function main() {
  try {
    log(colors.blue, '\nüöÄ D√©marrage de la g√©n√©ration de contenu...\n')

    // 1. V√©rifier que le fichier YAML existe
    if (!fs.existsSync(YAML_FILE)) {
      throw new Error(`‚ùå Fichier YAML non trouv√©: ${YAML_FILE}`)
    }
    log(colors.green, `‚úì Fichier YAML trouv√©`)

    // 2. Lire et parser le YAML
    const yamlContent = fs.readFileSync(YAML_FILE, 'utf-8')
    const data = YAML.parse(yamlContent)
    log(colors.green, `‚úì YAML pars√© avec succ√®s`)

    // 3. Valider les donn√©es
    const errors = validateYAML(data)
    if (errors.length > 0) {
      errors.forEach((err) => log(colors.red, err))
      throw new Error('‚ùå Validation √©chou√©e')
    }
    log(colors.green, `‚úì Toutes les validations pass√©es`)

    // 4. Cr√©er le r√©pertoire data s'il n'existe pas
    if (!fs.existsSync(DATA_DIR)) {
      fs.mkdirSync(DATA_DIR, { recursive: true })
      log(colors.green, `‚úì R√©pertoire cr√©√©: ${DATA_DIR}`)
    }

    // 5. G√©n√©rer les fichiers
    const wordsMap = generateWordsDatabase(data)
    const weeksProgram = generateWeeksProgram(data)

    writeWordsFile(wordsMap)
    writeWeeksFile(weeksProgram)
    writeTypesFile()

    // 6. Afficher les stats
    printStats(data)

    log(colors.green, '\n‚úÖ G√©n√©ration r√©ussie!\n')
    process.exit(0)
  } catch (error) {
    log(colors.red, `\n‚ùå ERREUR: ${error.message}\n`)
    process.exit(1)
  }
}

// Lancer le script
main()
